[toc]

# 第1章 概述

## 1.1 特征

- 语法简单  
  - 将 "++"、"--" 从运算符降级为语句，保留指针，但默认阻止指针运算。
- 并发模型
  - 从根子上将一切都并发化，运行时永 Goroutine 运行所有的一切，包括 main.main 入口函数。
  - Goroutine 是 Go 最显著的特征。它用类似协程的方式来处理并发单元，却又在运行时层面做了更深度的优化处理。
  - go语言中并发指的是让某个函数独立于其他函数运行的能力，一个goroutine就是一个独立的工作单元，Go的runtime（运行时）会在逻辑处理器上调度这些goroutine来运行，一个逻辑处理器绑定一个操作系统线程，所以说goroutine不是线程，它是一个协程，也是这个原因，它是由Go语言运行时本身的算法实现的。
- 内存分配
  - 除偶尔因性能问题而被迫采用对象池和自主内存管理外，我们基本无须参与内存管理操作。
- 垃圾回收
  - 当前版本的垃圾回收算法也只能说堪用，离好用尚有不少距离。
- 静态链接
  - 静态链接是 Go 的一大优点。
  - 目前 Go 也在完善动态库 buildmode 的功能。
- 标准库
  - 学习编程语言，早已不是学习一点语法规则那么简单。现在更习惯地称作选择 Ecosystem（生态圈），而这其中标准库的作用和分量尤为明显。
  - Go 标准库虽然称不得完全覆盖，但也算极为丰富。其中最值得称道的是 net/http，仅须简单几条语句就能实现一个高性能 Web Server。
- 工具链

## 1.2 简介

### 源文件

### 变量

### 表达式

### 函数

### 数据

### 方法

### 接口

### 并发

# 第2章 类型

## 2.1 变量

从计算机系统实现的角度来看，变量是一段或多段用来存储数据的内存。  
作为静态类型语言，Go 变量总是有固定的数据类型，类型决定了变量内存的长度和存储格式。  
我们只能修改变量值，无法改变类型。

- 定义
- 简短模式
- 退化赋值
- 多变量赋值
- 未使用错误

## 2.2 命名

### 命名建议

- 以字母或下划线开始，由多个字母、数字和下划线组合而成；
- 区分大小写；
- 使用驼峰拼写格式；
- 局部变量优先使用短名；
- 不要使用保留关键字；
- 不建议使用与预定义常量、类型、内置函数相同的名字；
- 专有名词通常会全部大写，例如 eacapeHTML

注：符号名字首字母大小写决定了其作用域。首字母大写的为导出成员，可被包外引用；而小写则仅能在包内使用。  

### 空标识符

空标识符 "_" 通常作为忽略占位符使用，可作为表达式左值，无法读取内容。  

## 2.3 常量  

- 常量
- 枚举
- 展开

## 2.4 基本类型

- bool
- byte
- int, uint
- int8, uint8
- int16, uint16
- int32, uint32
- int64, uint64
- float32
- float64
- complex64
- complex128
- rune
- uintptr
- string
- array
- struct
- function
- interface
- map
- slice
- channel

## 2.5 引用类型

所谓引用类型，特指 slice, map, channel 这三种预定义类型。  
内置函数 new 按指定类型长度分配零值内存，返回指针，并不关心类型内部构造和初始化方式。  
而引用类型则必须使用 make 函数创建，编译器会将 make 转换为目标类型专用的创建函数（或指令），以确保完成全部内存分配和相关属性初始化。  

new 函数也可以为引用类型分配内存，但这是不完整创建。  
以字典为例，它仅分配了字典类型本身（实际就是个指针包装）所需内存，并没有分配键值存储内存，也没有初始化散列桶等内部属性，因此它无法正常工作。  

## 2.6 类型转换

隐式转换造成的问题远大于它带来的好处。  
除常量、别名类型以及未命名类型外，Go 强制要求使用显式类型转换。  

### 语法歧义

为了避免造成语法分解错误，必须使用括号对目标是指针、单向通道、或没有返回值类型的函数类型进行转换。  

## 2.7 自定义类型  

# 第3章 表达式

## 3.1 保留字

- Go 语言仅25个保留关键字（keyword）  
  - break
  - case
  - chan
  - const
  - continue
  - default
  - defer
  - else
  - fallthrough
  - for
  - func
  - go
  - goto
  - if
  - import
  - interface
  - map
  - package
  - range
  - return
  - select
  - struct
  - switch
  - type
  - var

## 3.2 运算符  

### 全部运算符及分隔符列表  

### 优先级
- 一元运算符优先级最高
- 二元运算符优先级分成5个级别

### 二元运算符
- 除移位操作外，操作数类型必须相同
- 如果其中一个是无显式类型声明的常量，那么该常量操作数会自动转型  

### 位运算符

### 自增

自增、自减不再是运算符，只能作为独立语句，不能用于表达式。  
并且，没有前置形式。

### 指针  

 不能将内存地址与指针混为一谈。   
 指针类型支持相等运算符。   
 指针类型不能做加减法运算、不能进行类型转换。  
 指针统一使用 "." 选择表达式，没有专门指向成员的 “->” 运算符。   

 ## 3.3 初始化

- 对复合类型（数组、切片、字典、结构体）变量初始化时，有一些语法限制：
  - 初始化表达式必须含类型标签。
  - 左花括号必须在类型尾部，不能另起一行。
  - 多个成员初始值以逗号分隔。
  - 允许多行，但每行须以逗号或右花括号结束。
  
## 3.4 流控制

### if ... else ...

- 条件表达式值必须是布尔类型
- 支持初始化语句，可定义块局部变量（有效范围包含整个 if/else 语句块）或执行初始化函数

### switch

- case 语句中，可以通过 "," 列出多个匹配条件(or)，命中其中一个即可
- 支持初始化语句
- 按从上到下、从左到右顺序匹配 case 执行
- 只有全部匹配失败时，才会执行 default 块
- 相邻的空 case 不构成多条件匹配
- 不能出现重复的 case 常量值
- 无需显式执行 break 语句，case 执行完毕后自动中断
- 如需贯通后序 case （源码顺序），须执行 fallthrough（fallthrough 必须放在 case 块结尾），但不再匹配后续条件表达式
- break 语句可以阻止 fallthrough
- 某些时候，switch 还被用来替换 if 语句。省略的 switch 条件表达式默认值为 true，继而与 case 比较表达式结果匹配

### for 

- 仅有 for 一种循环语句，但常用方式都能支持
  > // 形式1    
    for i := 0; i < 3; i++ {  
    }  
    // 形式2  
    for x < 10 {    
    }  
    // 形式3  
    for {  
    }  
- for 的初始化表达式支持函数调用或定义局部变量  
  - 初始化语句中定义的函数调用仅执行一次
- for 的条件表达式支持函数调用
  - 条件表达式中的函数调用重复执行
- for ... range ... 
  - 用来完成数据迭代，支持字符串、数组、数组指针、切片、字典、通道
  - 返回索引、键值数据
  - 允许返回单值，此时，返回的是索引
  - range 会复制目标数据，然后在复制的数据上进行迭代，如果需要屏蔽该影响，可改用数组指针或切片类型
  - 如果 range 目标表达式是函数调用，也仅被执行一次
- for 循环和 range 迭代，其定义的局部变量都会重复使用   
  
### goto

- 使用 goto 前，须先定义标签。标签区分大小写，未使用的标签会引发编译错误
- 不能通过标签跳转到其他函数，或内层代码块

### break 和 continue

- 用于 switch、for、select 语句，终止整个语句块执行
- 仅用于 for 循环，终止后续逻辑，立即进入下一轮循环
- 配合标签，break 和 continue 可在多层嵌套中指定目标层级

# 第4章 函数

## 4.1 定义

- 关键字 func 用于定义函数
- Go 中函数的限制和优点
  - 无需前置声明
  - 不支持命名嵌套定义
  - 不支持同名函数重载
  - 不支持默认参数
  - 支持不定长变参
  - 支持多返回值
  - 支持命名返回值
  - 支持匿名函数和闭包
- 函数属于第一类对象，具备相同签名（参数及返回值列表）的视作同一类型
  - 第一类对象指可在运行期创建，可用作函数参数或返回值，可存入变量的实体。
  - 最常见的用法就是匿名函数
- 函数只能判断其是否为 nil，不支持其他比较操作
- 在 Go 中，从函数返回局部变量指针是安全的，编译器会通过逃逸分析（escape analysis）来决定是否在堆上分配内存

### 建议命名规则

## 4.2 参数

- 在参数列表中，相邻的同类型参数可合并
- 参数可视作函数局部变量，因此不能在相同层次定义同名变量
  - 形参是指函数定义中的参数，从实参复制数据
  - 实参是函数调用时所传递的参数
  - 在函数调用前，会为形参和返回值分配内存空间，并将实参拷贝到形参内存
- 要实现传出参数，通常建议使用返回值
- 如果函数参数过多，建议将其重构为一个复合结构类型

### 变参

- 变参本质上就是一个切片，只能接收一到多个同类型参数，且必须放在列表尾部
- 将切片作为变参时，须进行展开操作。如果是数组，先将其转换为切片
  > func test(a ...int) {  
    fmt.Println(a)  
  }  
  >
  > func main() {   
    a := [3]int{10,20,30}  
    test(a[:]...)  
  }  
- 变参是切片，所以参数复制的仅是切片自身，并不包括底层数组，因此可修改数据

## 4.3 返回值

- 有返回值的函数，必须有明确的 return 终止语句
- 除非有 panic，或者无 break 的死循环，则无须 return 终止语句
- 借鉴自动态语言的多返回值模式，函数得以返回更多状态，尤其是 error 模式
  
### 命名返回值

- 命名返回值和参数一样，可当作函数局部变量使用，最后由 return 隐式返回

## 4.4 匿名函数

- 除没有名字外，匿名函数和普通函数完全相同。区别在于，可在函数内部定义匿名函数，形成类似嵌套效果
- 匿名函数可直接调用，保存到变量，作为参数或返回值
- 普通函数和匿名函数都可作为结构体字段，或经通道传递
- 不曾使用的匿名函数会被编译器当作错误

### 闭包

- 闭包（closure）是在其词法上下文中引用了自由变量的函数，或者说是函数和其引用的环境的组合体
- 闭包通过指针引用环境变量，可能会导致其生命周期延长，甚至被分配到堆内存
- 此外，闭包还有所谓的“延迟求值”的特性
  
## 4.5 延迟调用

- 延迟调用即语句 defer 向当前函数注册稍后执行的函数调用
- 延迟调用直到当前函数执行结束前才被执行
- 常用于资源释放、解除锁定，以及错误处理等操作
- 延迟调用注册的是调用，必须提供执行所需参数（哪怕为空）。参数值在注册时被复制并缓存起来。如果对状态敏感，可改用指针或闭包
- 多个延迟调用按 FILO 次序执行
- return 和 panic 语句都会终止当前函数流程，引发延迟调用
- return 语句会在延迟调用之前，先更新返回值

### 误用

- 延迟调用在函数结束时才被执行。不合理的使用方式会浪费更多资源，甚至造成逻辑错误

### 性能

- 相比直接用 CALL 汇编指令调用函数，延迟调用则须花费更大代价。这其中包括注册调用等操作，还有额外的缓存开销
  
## 4.6 错误处理

### error

- 官方推荐的标准做法是返回 error 状态
- 标准库将 error 定义为接口类型，以便实现自定义错误类型
- 按惯例，error 总是最后一个返回参数
- 应通过错误变量，而非文本内容来判定错误类型
- 与 errors.New 类似的还有 fmt.Errorf，它返回一个格式化内容的错误对象

### panic, recover

- panic 会立即中断当前函数流程，执行延迟调用
- 在延迟调用函数中，recover 可捕获并返回 panic 提交的错误对象
- 无论是否执行 recover，所有延迟调用都会被执行。但中断性错误会沿调用堆栈向外传递，要么被外层捕获，要么导致进程崩溃
- 在延迟函数中 panic，不会影响后续延迟调用执行。而 recover 之后 panic，可被再次捕获
- recover 必须在延迟调用函数中执行才能正常工作
- 除非不可恢复性、导致系统无法正常工作的错误，否则不建议使用 panic

# 第5章 数据

## 5.1 字符串

- 字符串默认值不是 nil，而是 “”
- 使用 "`" 定义不做转义处理的原始字符串（raw string），支持跨行，并且，前置缩进、空格也属于字符串内容
- 支持 ！=， ==， <， >， +， +=， 其中，跨行时，+ 必须在上一行结尾
- 允许以索引号访问字节数组（非字符），但不能获取元素地址 
- 以切片语法（起始和结束索引号）返回子串时，其内部依旧指向原字节数组
- 使用 for 遍历字符串时，分 byte 和 rune 两种方式
  
### 转换

- 要修改字符串，须将其转换为可变类型（[]rune 或 []byte），待完成后再转换回来，但不管如何转换，都须重新分配内存，并复制数据
- 某些时候，转换操作会拖累算法性能，可尝试用“非安全”方法进行改善
- 用 append 函数，可将 string 直接追加到 []byte 内

### 性能

- 除类型转换外，动态构建字符串也很容易造成性能问题
- 用加法操作符拼接字符串时，每次都须重新分配内存，如此，在构建“超大”字符串时，性能就显得极差
- 改进思路是预分配足够的内存空间。常用方法是 strings.Join 函数，它会统计所有参数长度，并一次性完成内存分配操作

### Unicode

- 类型 rune 专门用来存储 Unicode 码点（code point），它是 int32 的别名
- 使用单引号的字面量，其默认类型就是 rune

## 5.2 数组

- 定义数组类型时，数组长度必须是非负整型常量表达式，长度是类型组成部分。也就是说，元素类型相同，但长度不同的数组不属于同一类型
- 灵活的初始化方式
  - 元素自动初始化为零
  - 未提供初始值的元素自动初始化为 0
  - 可指定索引位置初始化
  - 编译器按初始化值数量确定数组长度
  - 支持索引初始化，但注意数组长度与此有关
- 对于结构等复合类型，可省略元素初始化类型标签
- 在定义多维数组时，仅第一维度允许使用“...”
- 内置函数 len 和 cap 都返回第一维度长度
- 如元素类型支持 == != 操作符，那么数组也支持此操作

### 指针

- 指针数组是指元素为指针类型的数组
- 数组指针是指存储的值为数组变量的地址
- 数组指针可以是数组中任意元素的地址
- 数组指针可直接用来操作元素，支持 index 操作

### 复制

- 与 C 数组变量隐式作为指针使用不同，Go 数组是值类型，赋值和传参操作都会复制整个数组数据
- 如果需要，可改用指针或切片，以此避免数据复制

## 5.3 切片

- 切片本身并非动态数组或数组指针，它内部通过指针引用底层数组，设定相关属性将数据读写操作限定在指定区域内
  - 切片本身是个只读对象，其工作机制类似数组指针的一种包装
- 可基于数组或数组指针创建切片，以开始和结束索引位置确定所引用的数组片段。不支持反向索引，实际位置范围是一个左闭右开区间
- 属性 cap 表示切片所引用数据片段的真实长度，len 用于限定可读写的元素数量，数组必须 addressable，否则会引发错误
- 可直接创建切片对象，无须预先准备数组。因为是引用类型，须使用 make 函数或显式初始化语句，它会自动完成底层数组内存分配
- 不支持比较操作，就算元素类型支持也不行，仅能判断是否为 nil
- 可获取元素地址，但不能像数组那样直接用指针访问元素内容
- 如果元素类型也是切片，那么就可实现类似交错数组功能
- 很显然，切片只是很小的结构体对象，用来代替数组传参可避免复制开销。make 函数允许在运行期动态指定数组长度，绕开了数组类型必须使用编译期常量的限制

### reslice

- 将切片视作 [cap]slice 数据源，据此创建新切片对象，不能超出 cap ，但不受 len 限制
- 新建切片对象依旧指向原底层数组，也就是说修改对所有关联切片可见

### append 

- 向切片尾部添加数据，返回新的切片对象
- 数据被迫追加到原底层数组，如超出 cap 限制，则为新切片对象重新分配数组

### copy

- 在两个切片对象间复制数据，允许指向同一底层数组，允许目标区间重叠。最终所复制长度以较短的切片长度 len 为准
- 如果切片长时间引用大数组中很小的片段，那么建议新建独立切片，复制出所需数据，以便原数组内存可被及时回收

## 5.4 字典

- 作为无序键值对集合，字典要求 key 必须是支持相等运算符（==， ！=）的数据类型，比如，数字、字符串、指针、数组、结构体，以及对应接口类型
- 字典是引用类型，使用 make 函数或初始化表达式语句来创建
- 访问不存在的键值，默认返回零值，不会引发错误，但推荐使用 ok-idiom 模式，因为可能存储的 value 本来就是零
- 对字典进行迭代，每次返回的键值次序都不相同
- 函数 len 返回当前键值对数量，cap 不接受字典类型
- 字典被设计成 not addressable，故不能直接修改 value 成员（结构体或数组的成员）
  - 正确做法是返回整个 value，待修改后再设置字典键值，或直接用指针类型
  
### 安全

- 在迭代期间删除或新增键值是安全的
- 运行时会对字典并发操作作出检测，如果某个任务正在对字典进行写操作，那么其他任务就不能对该字典执行并发操作（读、写、删除），否则会导致进程崩溃
- 可用 sync.RWMutex 实现同步，避免读写操作同时进行

### 性能

- 字典对象本身就是指针包装，传参时无须再次取地址
- 在创建时预先准备足够空间有助于提升性能，减少扩张时的内存分配和重新哈希操作
- 对于海量小对象，应直接用字典存储键值数据拷贝，而非指针。这有助于减少需要扫描的对象数量，大幅缩短垃圾回收时间
- 字典不会收缩内存，所以，适当替换成新对象是必要的

## 5.5 结构

- 结构体将多个不同类型命名字段序列打包成一个复合类型
- 字段名、排列顺序属于类型组成部分
- 除对齐处理外，编译器不会优化、调整内存布局
- 可按顺序初始化全部字段，或使用命名方式初始化指定字段
- 可直接定义匿名结构类型变量，或用作字段类型，此时，无法直接初始化，稍显麻烦
- 只有在所有字段类型全部支持时，才可做相等操作
- 可使用指针直接操作结构字段，但不能是多级指针

### 空结构

- 空结构是指没有字段的结构类型。它比较特殊，因为无论是其自身，还是作为数组元素类型，其长度都为零

### 匿名字段

- 所谓匿名字段（anonymous field），是指没有名字，仅有类型的字段，也被称作嵌入字段或嵌入类型
- 从编译器角度看，这只是隐式地以类型名作为字段名字。可直接引用匿名字段的成员，但初始化时须当作独立字段
- 除接口指针和多级指针以外的任何命名类型都可以作为匿名字段
- 不能将基础类型和其指针类型同时嵌入，因为两者隐式名字相同
- 编译器从当前显式命名字段开始，逐步向内查找匿名字段成员，如匿名字段成员被外层同名字段遮蔽，那么必须使用显式字段名
- Go 并不是传统意义上的面向对象编程语言，或者说仅实现了最小面向对象机制

### 字段标签

- 字段标签(Tag)并不是注释，而是用来对字段进行描述的元数据
- 尽管字段标签并不属于数据成员，但却是类型的组成部分
- 在运行期，可用反射获取标签信息。它常被用作格式校验，数据库关系映射等

### 内存布局

- 不管结构体包含多少字段，其内存总是一次性分配的，各字段在相邻的地址空间按定义顺序排列
- 在分配内存时，字段须做对齐处理，通常以所有字段中最长的基础类型宽度作为标准
- 比较特殊的是空结构类型字段，如果它是最后一个字段，那么编译器将其当做长度为1的类型做对齐处理，以便其地址不会越界，避免引发垃圾回收错误

# 第6章 方法

## 6.1 定义

- 方法是与对象实例绑定的特殊函数
  - 对象是内敛的，每个实例都有各自不同的独立特征，以属性和方法来暴露对外通信接口
  - 普通函数则专注于算法流程，通过接收参数来完成特定逻辑运算，并返回最终结果
  - 方法是有关联状态的，而函数通常没有
- 可以为当前包，以及除接口和指针以外的任何类型定义方法
- 方法同样不支持重载
- receiver 参数名没有限制，按惯例会选用简短有意义的名称。如方法内部并不引用实例，可省略参数名，仅保留类型
- 方法可看做特殊的函数，那么 receiver 的类型自然可以是基础类型或指针类型。这会关系到调用时对象实例是否被复制
- 可使用实例值或指针调用方法，编译器会根据方法 receiver 类型自动在基础类型和指针类型间转换
- 不能使用多级指针调用方法
- 如何选择方法的 receiver 类型：
  - 要修改实例状态，用 *T
  - 无须修改状态的小对象或固定值，建议用 T
  - 大对象建议用 *T，以减少复制成本
  - 引用类型、字符串、函数等指针包装对象，直接用 T
  - 若包含 Mutex 等同步字段，用 *T，避免因复制造成锁操作无效
  - 其他无法确定的情况，都用 *T

## 6.2 匿名字段

- 可以像访问匿名字段成员那样调用其方法，由编译器负责查找
- 方法也会有同名遮蔽问题，但利用这种特性，可实现类似覆盖(override)操作
- 尽管能直接访问你名字段的成员和方法，但它们依然不属于继承关系

## 6.3 方法集

- 类型有一个与之相关的方法集（method set），这决定了它是否实现某个接口
  - 类型 T 方法集包含所有 receiver T 方法
  - 类型 *T 方法集包含所有 receiver T + *T 方法
  - 匿名嵌入 S，T 方法集包含所有 receiver S 方法
  - 匿名嵌入 *S，T 方法集包含所有 receiver S + *S 方法
  - 匿名嵌入 S 或 *S，*T 方法集包含所有 receiver S + *S 方法
- 方法集仅影响接口实现和方法表达式转换，与通过实例或实例指针调用方法无关。实例并不使用方法集，而是直接调用
- 显然，匿名字段就是为方法集准备的
- 面向对象的三大特征“封装”，“继承”，“多态”，Go 仅实现了部分特征，它更倾向于“组合优于继承”这种思想
  - 将模块分解成相互独立的更小单元，分别处理不同方面的需求，最后以匿名嵌入方式组合到一起，共同实现对外接口

## 6.4 表达式

- 方法和函数一样，除直接调用外，还可赋值给变量，或作为参数传递。  
- 依照具体引用方式的不同，可分为 expression 和 value 两种状态。  

### Method Expression

- 通过类型引用的 method expression 会被还原为普通函数样式，receiver 是第一参数，调用时须显式传参
- 至于类型，可以是 T 或 *T，只要目标方法存在于该类型方法集中即可
- 也可以直接以表达式方式调用

### Method Value

- 基于实例或指针引用的 method value，参数签名不会改变，依旧按照正常方式调用
- 但当 method value 被赋值给变量或作为参数传递时，会立即计算并复制该方法执行所需的 receiver 对象，与其绑定，以便在稍后执行时，能隐式传入 receiver 参数
- 当 method value 作为参数时，会复制含 receiver 在内的整个 method value 
- 如果目标方法的 receiver 是指针类型，那么被复制的仅是指针

# 第7章 接口

## 7.1 定义

- 接口要实现的是做什么，而不关心怎么做、谁来做
- 接口最常见的使用场景，是对包外提供访问，或预留扩展空间
- Go 接口实现机制很简单，只要目标类型方法集内包含接口声明的全部方法，就被视为实现了该接口，无须做显式声明。当然，目标类型可实现多个接口
- 接口的限制
  - 不能有字段
  - 不能定义自己的方法
  - 只能声明方法，不能实现
  - 可嵌入其他接口类型
- 接口通常以 er 作为名称后缀，方法名是声明组成部分，但参数名可不同或省略
- 编译器根据方法集来判断是否实现了接口
- 可以像匿名字段那样，嵌入其他接口。目标类型方法集中必须拥有包含嵌入接口方法在内的全部方法才算实现了该接口
  - 嵌入其他接口类型，相当于将其声明的方法集导入，这就要求不能有同名方法，因为不支持重载
  - 不能嵌入自身或循环嵌入，否则会导致递归错误
- 超集接口变量可隐式转换为子集，但反过来不行
- 支持匿名接口类型，可直接用于变量定义，或作为结构字段类型

## 7.2 执行机制

- 接口使用一个名为 itab 的结构存储运行期所需的相关类型信息
- 接口的重要特征：将对象赋值给接口变量时，会复制该对象

## 7.3 类型转换

- 类型推断可将接口变量还原为原始类型，或用来判断是否实现了某个更具体的接口类型
- 使用 ok-idiom 模式，即便转换失败也不会引发 panic

## 7.4 技巧

- 让编译器检查，确保类型实现了指定接口
- 定义函数类型，让相同签名的函数自动实现某个接口

# 第8章 并发

## 8.1 并发的含义

- 并发：逻辑上具备同时处理多个任务的能力
- 并行：物理上同一时刻执行多个并发任务
- 多线程或多进程是并行的基本条件，但单线程也可以用协程（coroutine）做到并发。尽管协程在单个线程上通过主动切换来实现多任务并发，但它也有自己的优势。除了将因阻塞而浪费的时间找回来外，还免去了线程切换开销，有着不错的执行效率。协程上运行的多个任务本质上是依旧串行的，加上可控自主调度，所以并不需要做同步处理
- 只须在函数调用前添加 go 关键字，即可创建并发任务
- 关键字 go 并非执行并发操作，而是创建一个并发任务单元
- 与 defer 一样，goroutine 也会因“延迟执行”而立即计算并复制执行参数

### wait 

- 进程退出时不会等待并发任务结束，可用通道（channel）阻塞，然后发出退出信号
- 如果要等待多个任务结束，推荐使用 sync.WaitGroup，通过设定计数器，让每个 goroutine 在退出前递减，直至归零时解除阻塞
- 尽管 WaitGroup.Add 实现了原子操作，但建议在 goroutine 外累加计数器，以免 Add 尚未执行，wait 已经退出
- 可在多处使用 wait 阻塞，它们都能接收到通知

### GOMAXPROCS

- 运行时可能会创建很多线程，但任何时候仅有限的几个线程参与并发任务执行。该数量默认与处理器核数相等，可用 runtime.GOMAXPROCS 函数修改

### Local Storage

- 与线程不同，goroutine 任务无法设置优先级，无法获取编号，没有局部存储（TLS），甚至连返回值都会被抛弃。但除优先级外，其他功能都很容易实现（通过闭包实现）

### Gosched

- 暂停，释放线程去执行其他任务，当前任务被放回队列，等待下次调度时恢复执行
- 该函数很少被使用，因为运行时会主动向长时间运行（10ms）的任务发出抢占调度

### Goexit

- 立即终止当前任务，运行时确保所有已注册延迟调用被执行
- 该函数不会影响其他并发任务，不会引发 panic，自然也就无法捕获
- 如果在 main.main 里调用 Goexit，它会等待其他任务结束，然后让进程直接崩溃

## 8.2 通道

- 允许全局变量，指针，引用类型这些非安全内存共享操作，就需要开发人员自行维护数据一致和完整性
- Go 鼓励使用 CSP 通道，以通信来代替内存共享，实现并发安全
- 通过消息来避免竟态的模型除了 CSP，还有 Actor，但两者有较大区别
- 通道（channel）是 CSP 的核心，要求操作双方必须知道数据类型和具体通道，并不关心另一端操作者身份和数量。可如果另一端未准备妥当，或消息未能及时处理时，会阻塞当前端
- Actor 是透明的，它不在乎数据类型和通道，只要知道接收者信箱即可。默认就是异步方式，发送方对消息是否被接收和处理并不关心
- 同步模式必须有配对操作的 goroutine 出现，否则会一直阻塞。而异步模式在缓冲区未满或数据未读完之前，不会阻塞
- 缓冲区大小仅是内部属性，不属于类型组成部分。另外通道变量本身就是指针，可用相等操作符判断是否为同一对象或 nil
  - 虽然可以传递指针来避免数据复制，但须额外注意数据并发安全
- 内置函数 cap 和 len 返回缓冲区大小和当前已缓冲数量；而对于同步通道，则都返回0；据此，可判断通道是同步还是异步

### 收发

- 除使用简单的发送和接收操作符外，还可用 ok-idom 或 range 模式处理数据
- 对于循环接收数据，range 模式更简洁一些
  - range 模式会循环接收数据，知道通道被关闭
- 对于 closed 或 nil 通道，发送和接收操作都有相应规则
  - 向已关闭通道发送数据，会引发 panic
  - 从已关闭通道接收数据，返回已缓冲数据或零值
  - 无论收发，nil 通道都会阻塞

### 单向

- 通常使用类型转换来获取单向通道，并分别赋予操作双方
- 不能再单向通道上做逆向操作
- 同样，close 不能用于接收端
- 无法将单向通道重新转换回去

### 选择

- 如要同时处理多个通道，可选用 select 语句，它会随机选择一个可用通道做收发操作
- 如果要等全部通道消息处理结束（closed），可将已完成通道设置为 nil，这样，它就会被阻塞，不再被 select 选中
- 即便是同一通道，也会随机选择 case 执行
- 当所有通道都不可用时，select 会执行 default 语句。如此，可避开 select 阻塞，但需注意处理外层循环，以免陷入空耗

### 模式

- 通常使用工厂方法将 goroutine 和通道绑定
- 鉴于通道本身就是一个并发安全的队列，可用作 ID generator、Pool 等用途
- 用通道实现信号量
- 标准库 time 提供了 timeout 和 tick channel 实现
- 捕获 INT、TERM 信号，顺便实现一个简易 atexit 函数

### 性能

- 将发往通道的数据打包，减少传输次数，可有效提升性能。
- 从实现上来说，通道队列依旧使用锁同步机制，单次获取更多数据（批处理），可改善因频繁加锁造成的性能问题

### 资源泄漏

- 通道可能会引发 goroutine leak，确切地说，是指 goroutine 处于发送或接受阻塞状态，但一直未被唤醒。垃圾回收器并不收集此类资源，导致它们会在等待队列里长久休眠，形成资源泄漏

## 8.3 同步

- 通道并非用来取代锁的，它们有各自不同的使用场景
  - 通道倾向于解决逻辑层次的并发处理架构
  - 锁用来保护局部范围内的数据安全
- 标准库 sync 提供了互斥和读写锁，另有原子操作等，可基本满足日常开发需要
  - 将 Mutex 作为匿名字段时，相关方法必须实现为 pointer-receiver，否则会因复制导致锁机制失效
  - 应将 Mutex 锁粒度控制在最小范围内，及早释放
  - Mutex 不支持递归锁，即便在同一 goroutine 下也会导致死锁
    - 在设计并发安全类型时，千万注意各种情况下的此类问题
- 相关建议
  - 对性能要求较高时，应避免使用 defer Unlock
  - 读写并发时，用 RWMutex 性能会更好一些
  - 对单个数据读写保护，可尝试用原子操作
  - 执行严格测试，尽可能打开数据竞争检查

# 第9章 包结构

## 9.1 工作空间



