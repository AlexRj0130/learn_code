[toc]

# 第1章 概述

## 1.1 特征

- 语法简单  
  - 将 "++"、"--" 从运算符降级为语句，保留指针，但默认阻止指针运算。
- 并发模型
  - 从根子上将一切都并发化，运行时永 Goroutine 运行所有的一切，包括 main.main 入口函数。
  - Goroutine 是 Go 最显著的特征。它用类似协程的方式来处理并发单元，却又在运行时层面做了更深度的优化处理。
  - go语言中并发指的是让某个函数独立于其他函数运行的能力，一个goroutine就是一个独立的工作单元，Go的runtime（运行时）会在逻辑处理器上调度这些goroutine来运行，一个逻辑处理器绑定一个操作系统线程，所以说goroutine不是线程，它是一个协程，也是这个原因，它是由Go语言运行时本身的算法实现的。
- 内存分配
  - 除偶尔因性能问题而被迫采用对象池和自主内存管理外，我们基本无须参与内存管理操作。
- 垃圾回收
  - 当前版本的垃圾回收算法也只能说堪用，离好用尚有不少距离。
- 静态链接
  - 静态链接是 Go 的一大优点。
  - 目前 Go 也在完善动态库 buildmode 的功能。
- 标准库
  - 学习编程语言，早已不是学习一点语法规则那么简单。现在更习惯地称作选择 Ecosystem（生态圈），而这其中标准库的作用和分量尤为明显。
  - Go 标准库虽然称不得完全覆盖，但也算极为丰富。其中最值得称道的是 net/http，仅须简单几条语句就能实现一个高性能 Web Server。
- 工具链

## 1.2 简介

### 源文件

### 变量

### 表达式

### 函数

### 数据

### 方法

### 接口

### 并发

# 第2章 类型

## 2.1 变量

从计算机系统实现的角度来看，变量是一段或多段用来存储数据的内存。  
作为静态类型语言，Go 变量总是有固定的数据类型，类型决定了变量内存的长度和存储格式。  
我们只能修改变量值，无法改变类型。

- 定义
- 简短模式
- 退化赋值
- 多变量赋值
- 未使用错误

## 2.2 命名

### 命名建议

- 以字母或下划线开始，由多个字母、数字和下划线组合而成；
- 区分大小写；
- 使用驼峰拼写格式；
- 局部变量优先使用短名；
- 不要使用保留关键字；
- 不建议使用与预定义常量、类型、内置函数相同的名字；
- 专有名词通常会全部大写，例如 eacapeHTML

注：符号名字首字母大小写决定了其作用域。首字母大写的为导出成员，可被包外引用；而小写则仅能在包内使用。  

### 空标识符

空标识符 "_" 通常作为忽略占位符使用，可作为表达式左值，无法读取内容。  

## 2.3 常量  

- 常量
- 枚举
- 展开

## 2.4 基本类型

- bool
- byte
- int, uint
- int8, uint8
- int16, uint16
- int32, uint32
- int64, uint64
- float32
- float64
- complex64
- complex128
- rune
- uintptr
- string
- array
- struct
- function
- interface
- map
- slice
- channel

## 2.5 引用类型

所谓引用类型，特指 slice, map, channel 这三种预定义类型。  
内置函数 new 按指定类型长度分配零值内存，返回指针，并不关心类型内部构造和初始化方式。  
而引用类型则必须使用 make 函数创建，编译器会将 make 转换为目标类型专用的创建函数（或指令），以确保完成全部内存分配和相关属性初始化。  

new 函数也可以为引用类型分配内存，但这是不完整创建。  
以字典为例，它仅分配了字典类型本身（实际就是个指针包装）所需内存，并没有分配键值存储内存，也没有初始化散列桶等内部属性，因此它无法正常工作。  

## 2.6 类型转换

隐式转换造成的问题远大于它带来的好处。  
除常量、别名类型以及未命名类型外，Go 强制要求使用显式类型转换。  

### 语法歧义

为了避免造成语法分解错误，必须使用括号对目标是指针、单向通道、或没有返回值类型的函数类型进行转换。  

## 2.7 自定义类型  

# 第3章 表达式

## 3.1 保留字

- Go 语言仅25个保留关键字（keyword）  
  - break
  - case
  - chan
  - const
  - continue
  - default
  - defer
  - else
  - fallthrough
  - for
  - func
  - go
  - goto
  - if
  - import
  - interface
  - map
  - package
  - range
  - return
  - select
  - struct
  - switch
  - type
  - var

## 3.2 运算符  

### 全部运算符及分隔符列表  

### 优先级
- 一元运算符优先级最高
- 二元运算符优先级分成5个级别

### 二元运算符
- 除移位操作外，操作数类型必须相同
- 如果其中一个是无显式类型声明的常量，那么该常量操作数会自动转型  

### 位运算符

### 自增

自增、自减不再是运算符，只能作为独立语句，不能用于表达式。  
并且，没有前置形式。

### 指针  

 不能将内存地址与指针混为一谈。   
 指针类型支持相等运算符。   
 指针类型不能做加减法运算、不能进行类型转换。  
 指针统一使用 "." 选择表达式，没有专门指向成员的 “->” 运算符。   

 ## 3.3 初始化

- 对复合类型（数组、切片、字典、结构体）变量初始化时，有一些语法限制：
  - 初始化表达式必须含类型标签。
  - 左花括号必须在类型尾部，不能另起一行。
  - 多个成员初始值以逗号分隔。
  - 允许多行，但每行须以逗号或右花括号结束。
  
## 3.4 流控制

### if ... else ...

- 条件表达式值必须是布尔类型
- 支持初始化语句，可定义块局部变量（有效范围包含整个 if/else 语句块）或执行初始化函数

### switch

- case 语句中，可以通过 "," 列出多个匹配条件(or)，命中其中一个即可
- 支持初始化语句
- 按从上到下、从左到右顺序匹配 case 执行
- 只有全部匹配失败时，才会执行 default 块
- 相邻的空 case 不构成多条件匹配
- 不能出现重复的 case 常量值
- 无需显式执行 break 语句，case 执行完毕后自动中断
- 如需贯通后序 case （源码顺序），须执行 fallthrough（fallthrough 必须放在 case 块结尾），但不再匹配后续条件表达式
- break 语句可以阻止 fallthrough
- 某些时候，switch 还被用来替换 if 语句。省略的 switch 条件表达式默认值为 true，继而与 case 比较表达式结果匹配

### for 

- 仅有 for 一种循环语句，但常用方式都能支持
  > // 形式1    
    for i := 0; i < 3; i++ {  
    }  
    // 形式2  
    for x < 10 {    
    }  
    // 形式3  
    for {  
    }  
- for 的初始化表达式支持函数调用或定义局部变量  
  - 初始化语句中定义的函数调用仅执行一次
- for 的条件表达式支持函数调用
  - 条件表达式中的函数调用重复执行
- for ... range ... 
  - 用来完成数据迭代，支持字符串、数组、数组指针、切片、字典、通道
  - 返回索引、键值数据
  - 允许返回单值，此时，返回的是索引
  - range 会复制目标数据，然后在复制的数据上进行迭代，如果需要屏蔽该影响，可改用数组指针或切片类型
  - 如果 range 目标表达式是函数调用，也仅被执行一次
- for 循环和 range 迭代，其定义的局部变量都会重复使用   
  
### goto

- 使用 goto 前，须先定义标签。标签区分大小写，未使用的标签会引发编译错误
- 不能通过标签跳转到其他函数，或内层代码块

### break 和 continue

- 用于 switch、for、select 语句，终止整个语句块执行
- 仅用于 for 循环，终止后续逻辑，立即进入下一轮循环
- 配合标签，break 和 continue 可在多层嵌套中指定目标层级