[toc]

# 第1章 概述

## 1.1 特征

- 语法简单  
  - 将 "++"、"--" 从运算符降级为语句，保留指针，但默认阻止指针运算。
- 并发模型
  - 从根子上将一切都并发化，运行时永 Goroutine 运行所有的一切，包括 main.main 入口函数。
  - Goroutine 是 Go 最显著的特征。它用类似协程的方式来处理并发单元，却又在运行时层面做了更深度的优化处理。
  - go语言中并发指的是让某个函数独立于其他函数运行的能力，一个goroutine就是一个独立的工作单元，Go的runtime（运行时）会在逻辑处理器上调度这些goroutine来运行，一个逻辑处理器绑定一个操作系统线程，所以说goroutine不是线程，它是一个协程，也是这个原因，它是由Go语言运行时本身的算法实现的。
- 内存分配
  - 除偶尔因性能问题而被迫采用对象池和自主内存管理外，我们基本无须参与内存管理操作。
- 垃圾回收
  - 当前版本的垃圾回收算法也只能说堪用，离好用尚有不少距离。
- 静态链接
  - 静态链接是 Go 的一大优点。
  - 目前 Go 也在完善动态库 buildmode 的功能。
- 标准库
  - 学习编程语言，早已不是学习一点语法规则那么简单。现在更习惯地称作选择 Ecosystem（生态圈），而这其中标准库的作用和分量尤为明显。
  - Go 标准库虽然称不得完全覆盖，但也算极为丰富。其中最值得称道的是 net/http，仅须简单几条语句就能实现一个高性能 Web Server。
- 工具链

## 1.2 简介

### 源文件

### 变量

### 表达式

### 函数

### 数据

### 方法

### 接口

### 并发

# 第2章 类型

## 2.1 变量

从计算机系统实现的角度来看，变量是一段或多段用来存储数据的内存。  
作为静态类型语言，Go 变量总是有固定的数据类型，类型决定了变量内存的长度和存储格式。  
我们只能修改变量值，无法改变类型。

- 定义
- 简短模式
- 退化赋值
- 多变量赋值
- 未使用错误

## 2.2 命名

### 命名建议

- 以字母或下划线开始，由多个字母、数字和下划线组合而成；
- 区分大小写；
- 使用驼峰拼写格式；
- 局部变量优先使用短名；
- 不要使用保留关键字；
- 不建议使用与预定义常量、类型、内置函数相同的名字；
- 专有名词通常会全部大写，例如 eacapeHTML

注：符号名字首字母大小写决定了其作用域。首字母大写的为导出成员，可被包外引用；而小写则仅能在包内使用。  

### 空标识符

空标识符 "_" 通常作为忽略占位符使用，可作为表达式左值，无法读取内容。  

## 2.3 常量  

- 常量
- 枚举
- 展开

## 2.4 基本类型

- bool
- byte
- int, uint
- int8, uint8
- int16, uint16
- int32, uint32
- int64, uint64
- float32
- float64
- complex64
- complex128
- rune
- uintptr
- string
- array
- struct
- function
- interface
- map
- slice
- channel

## 2.5 引用类型

所谓引用类型，特指 slice, map, channel 这三种预定义类型。  
内置函数 new 按指定类型长度分配零值内存，返回指针，并不关心类型内部构造和初始化方式。  
而引用类型则必须使用 make 函数创建，编译器会将 make 转换为目标类型专用的创建函数（或指令），以确保完成全部内存分配和相关属性初始化。  

new 函数也可以为引用类型分配内存，但这是不完整创建。  
以字典为例，它仅分配了字典类型本身（实际就是个指针包装）所需内存，并没有分配键值存储内存，也没有初始化散列桶等内部属性，因此它无法正常工作。  

## 2.6 类型转换

隐式转换造成的问题远大于它带来的好处。  
除常量、别名类型以及未命名类型外，Go 强制要求使用显式类型转换。  

### 语法歧义

为了避免造成语法分解错误，必须使用括号对目标是指针、单向通道、或没有返回值类型的函数类型进行转换。  

## 2.7 自定义类型  

# 第3章 表达式

## 3.1 保留字

- Go 语言仅25个保留关键字（keyword）  
  - break
  - case
  - chan
  - const
  - continue
  - default
  - defer
  - else
  - fallthrough
  - for
  - func
  - go
  - goto
  - if
  - import
  - interface
  - map
  - package
  - range
  - return
  - select
  - struct
  - switch
  - type
  - var

## 3.2 运算符  

### 全部运算符及分隔符列表  

### 优先级
- 一元运算符优先级最高
- 二元运算符优先级分成5个级别

### 二元运算符
- 除移位操作外，操作数类型必须相同
- 如果其中一个是无显式类型声明的常量，那么该常量操作数会自动转型  

### 位运算符

### 自增

自增、自减不再是运算符，只能作为独立语句，不能用于表达式。  
并且，没有前置形式。

### 指针  

 不能将内存地址与指针混为一谈。   
 指针类型支持相等运算符。   
 指针类型不能做加减法运算、不能进行类型转换。  
 指针统一使用 "." 选择表达式，没有专门指向成员的 “->” 运算符。   

 ## 3.3 初始化

- 对复合类型（数组、切片、字典、结构体）变量初始化时，有一些语法限制：
  - 初始化表达式必须含类型标签。
  - 左花括号必须在类型尾部，不能另起一行。
  - 多个成员初始值以逗号分隔。
  - 允许多行，但每行须以逗号或右花括号结束。
  
## 3.4 流控制

### if ... else ...

- 条件表达式值必须是布尔类型
- 支持初始化语句，可定义块局部变量（有效范围包含整个 if/else 语句块）或执行初始化函数

### switch

- case 语句中，可以通过 "," 列出多个匹配条件(or)，命中其中一个即可
- 支持初始化语句
- 按从上到下、从左到右顺序匹配 case 执行
- 只有全部匹配失败时，才会执行 default 块
- 相邻的空 case 不构成多条件匹配
- 不能出现重复的 case 常量值
- 无需显式执行 break 语句，case 执行完毕后自动中断
- 如需贯通后序 case （源码顺序），须执行 fallthrough（fallthrough 必须放在 case 块结尾），但不再匹配后续条件表达式
- break 语句可以阻止 fallthrough
- 某些时候，switch 还被用来替换 if 语句。省略的 switch 条件表达式默认值为 true，继而与 case 比较表达式结果匹配

### for 

- 仅有 for 一种循环语句，但常用方式都能支持
  > // 形式1    
    for i := 0; i < 3; i++ {  
    }  
    // 形式2  
    for x < 10 {    
    }  
    // 形式3  
    for {  
    }  
- for 的初始化表达式支持函数调用或定义局部变量  
  - 初始化语句中定义的函数调用仅执行一次
- for 的条件表达式支持函数调用
  - 条件表达式中的函数调用重复执行
- for ... range ... 
  - 用来完成数据迭代，支持字符串、数组、数组指针、切片、字典、通道
  - 返回索引、键值数据
  - 允许返回单值，此时，返回的是索引
  - range 会复制目标数据，然后在复制的数据上进行迭代，如果需要屏蔽该影响，可改用数组指针或切片类型
  - 如果 range 目标表达式是函数调用，也仅被执行一次
- for 循环和 range 迭代，其定义的局部变量都会重复使用   
  
### goto

- 使用 goto 前，须先定义标签。标签区分大小写，未使用的标签会引发编译错误
- 不能通过标签跳转到其他函数，或内层代码块

### break 和 continue

- 用于 switch、for、select 语句，终止整个语句块执行
- 仅用于 for 循环，终止后续逻辑，立即进入下一轮循环
- 配合标签，break 和 continue 可在多层嵌套中指定目标层级

# 第4章 函数

## 4.1 定义

- 关键字 func 用于定义函数
- Go 中函数的限制和优点
  - 无需前置声明
  - 不支持命名嵌套定义
  - 不支持同名函数重载
  - 不支持默认参数
  - 支持不定长变参
  - 支持多返回值
  - 支持命名返回值
  - 支持匿名函数和闭包
- 函数属于第一类对象，具备相同签名（参数及返回值列表）的视作同一类型
  - 第一类对象指可在运行期创建，可用作函数参数或返回值，可存入变量的实体。
  - 最常见的用法就是匿名函数
- 函数只能判断其是否为 nil，不支持其他比较操作
- 在 Go 中，从函数返回局部变量指针是安全的，编译器会通过逃逸分析（escape analysis）来决定是否在堆上分配内存

### 建议命名规则

## 4.2 参数

- 在参数列表中，相邻的同类型参数可合并
- 参数可视作函数局部变量，因此不能在相同层次定义同名变量
  - 形参是指函数定义中的参数，从实参复制数据
  - 实参是函数调用时所传递的参数
  - 在函数调用前，会为形参和返回值分配内存空间，并将实参拷贝到形参内存
- 要实现传出参数，通常建议使用返回值
- 如果函数参数过多，建议将其重构为一个复合结构类型

### 变参

- 变参本质上就是一个切片，只能接收一到多个同类型参数，且必须放在列表尾部
- 将切片作为变参时，须进行展开操作。如果是数组，先将其转换为切片
  > func test(a ...int) {  
    fmt.Println(a)  
  }  
  >
  > func main() {   
    a := [3]int{10,20,30}  
    test(a[:]...)  
  }  
- 变参是切片，所以参数复制的仅是切片自身，并不包括底层数组，因此可修改数据

## 4.3 返回值

- 有返回值的函数，必须有明确的 return 终止语句
- 除非有 panic，或者无 break 的死循环，则无须 return 终止语句
- 借鉴自动态语言的多返回值模式，函数得以返回更多状态，尤其是 error 模式
  
### 命名返回值

- 命名返回值和参数一样，可当作函数局部变量使用，最后由 return 隐式返回

## 4.4 匿名函数

- 除没有名字外，匿名函数和普通函数完全相同。区别在于，可在函数内部定义匿名函数，形成类似嵌套效果
- 匿名函数可直接调用，保存到变量，作为参数或返回值
- 普通函数和匿名函数都可作为结构体字段，或经通道传递
- 不曾使用的匿名函数会被编译器当作错误

### 闭包

- 闭包（closure）是在其词法上下文中引用了自由变量的函数，或者说是函数和其引用的环境的组合体
- 闭包通过指针引用环境变量，可能会导致其生命周期延长，甚至被分配到堆内存
- 此外，闭包还有所谓的“延迟求值”的特性
  
## 4.5 延迟调用

- 延迟调用即语句 defer 向当前函数注册稍后执行的函数调用
- 延迟调用直到当前函数执行结束前才被执行
- 常用于资源释放、解除锁定，以及错误处理等操作
- 延迟调用注册的是调用，必须提供执行所需参数（哪怕为空）。参数值在注册时被复制并缓存起来。如果对状态敏感，可改用指针或闭包
- 多个延迟调用按 FILO 次序执行
- return 和 panic 语句都会终止当前函数流程，引发延迟调用
- return 语句会在延迟调用之前，先更新返回值

### 误用

- 延迟调用在函数结束时才被执行。不合理的使用方式会浪费更多资源，甚至造成逻辑错误

### 性能

- 相比直接用 CALL 汇编指令调用函数，延迟调用则须花费更大代价。这其中包括注册调用等操作，还有额外的缓存开销
  
## 4.6 错误处理

### error

- 官方推荐的标准做法是返回 error 状态
- 标准库将 error 定义为接口类型，以便实现自定义错误类型
- 按惯例，error 总是最后一个返回参数
- 应通过错误变量，而非文本内容来判定错误类型
- 与 errors.New 类似的还有 fmt.Errorf，它返回一个格式化内容的错误对象

### panic, recover

- panic 会立即中断当前函数流程，执行延迟调用
- 在延迟调用函数中，recover 可捕获并返回 panic 提交的错误对象
- 无论是否执行 recover，所有延迟调用都会被执行。但中断性错误会沿调用堆栈向外传递，要么被外层捕获，要么导致进程崩溃
- 在延迟函数中 panic，不会影响后续延迟调用执行。而 recover 之后 panic，可被再次捕获
- recover 必须在延迟调用函数中执行才能正常工作
- 除非不可恢复性、导致系统无法正常工作的错误，否则不建议使用 panic

# 第5章 数据

## 5.1 字符串

- 字符串默认值不是 nil，而是 “”
- 使用 "`" 定义不做转义处理的原始字符串（raw string），支持跨行，并且，前置缩进、空格也属于字符串内容
- 支持 ！=， ==， <， >， +， +=， 其中，跨行时，+ 必须在上一行结尾
- 允许以索引号访问字节数组（非字符），但不能获取元素地址 
- 以切片语法（起始和结束索引号）返回子串时，其内部依旧指向原字节数组
- 使用 for 遍历字符串时，分 byte 和 rune 两种方式
  
### 转换

- 要修改字符串，须将其转换为可变类型（[]rune 或 []byte），待完成后再转换回来，但不管如何转换，都须重新分配内存，并复制数据
- 某些时候，转换操作会拖累算法性能，可尝试用“非安全”方法进行改善
- 用 append 函数，可将 string 直接追加到 []byte 内

### 性能

- 除类型转换外，动态构建字符串也很容易造成性能问题
- 用加法操作符拼接字符串时，每次都须重新分配内存，如此，在构建“超大”字符串时，性能就显得极差
- 改进思路是预分配足够的内存空间。常用方法是 strings.Join 函数，它会统计所有参数长度，并一次性完成内存分配操作

### Unicode

- 类型 rune 专门用来存储 Unicode 码点（code point），它是 int32 的别名
- 使用单引号的字面量，其默认类型就是 rune

## 5.2 数组

- 定义数组类型时，数组长度必须是非负整型常量表达式，长度是类型组成部分。也就是说，元素类型相同，但长度不同的数组不属于同一类型
- 灵活的初始化方式
  - 元素自动初始化为零
  - 未提供初始值的元素自动初始化为 0
  - 可指定索引位置初始化
  - 编译器按初始化值数量确定数组长度
  - 支持索引初始化，但注意数组长度与此有关
- 对于结构等复合类型，可省略元素初始化类型标签
- 在定义多维数组时，仅第一维度允许使用“...”
- 内置函数 len 和 cap 都返回第一维度长度
- 如元素类型支持 == != 操作符，那么数组也支持此操作

### 指针

- 指针数组是指元素为指针类型的数组
- 数组指针是指存储的值为数组变量的地址
- 数组指针可以是数组中任意元素的地址
- 数组指针可直接用来操作元素，支持 index 操作

### 复制

- 与 C 数组变量隐式作为指针使用不同，Go 数组是值类型，赋值和传参操作都会复制整个数组数据
- 如果需要，可改用指针或切片，以此避免数据复制

## 5.3 切片

- 切片本身并非动态数组或数组指针，它内部通过指针引用底层数组，设定相关属性将数据读写操作限定在指定区域内
  - 切片本身是个只读对象，其工作机制类似数组指针的一种包装
- 可基于数组或数组指针创建切片，以开始和结束索引位置确定所引用的数组片段。不支持反向索引，实际位置范围是一个左闭右开区间
- 属性 cap 表示切片所引用数据片段的真实长度，len 用于限定可读写的元素数量，数组必须 addressable，否则会引发错误
- 可直接创建切片对象，无须预先准备数组。因为是引用类型，须使用 make 函数或显式初始化语句，它会自动完成底层数组内存分配
- 不支持比较操作，就算元素类型支持也不行，仅能判断是否为 nil
- 可获取元素地址，但不能像数组那样直接用指针访问元素内容
- 如果元素类型也是切片，那么就可实现类似交错数组功能
- 很显然，切片只是很小的结构体对象，用来代替数组传参可避免复制开销。make 函数允许在运行期动态指定数组长度，绕开了数组类型必须使用编译期常量的限制

### reslice

- 将切片视作 [cap]slice 数据源，据此创建新切片对象，不能超出 cap ，但不受 len 限制
- 新建切片对象依旧指向原底层数组，也就是说修改对所有关联切片可见

### append 

- 向切片尾部添加数据，返回新的切片对象
- 数据被迫追加到原底层数组，如超出 cap 限制，则为新切片对象重新分配数组

### copy

- 在两个切片对象间复制数据，允许指向同一底层数组，允许目标区间重叠。最终所复制长度以较短的切片长度 len 为准
- 如果切片长时间引用大数组中很小的片段，那么建议新建独立切片，复制出所需数据，以便原数组内存可被及时回收

## 5.4 字典


